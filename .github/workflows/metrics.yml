# Metrics and Monitoring Workflow
# Collects and reports on repository and workflow metrics

name: Metrics & Monitoring

on:
  schedule:
    # Run daily at 6 AM UTC
    - cron: '0 6 * * *'
  workflow_dispatch:
    inputs:
      report_type:
        description: 'Type of report to generate'
        required: true
        default: 'daily'
        type: choice
        options:
          - daily
          - weekly
          - monthly

permissions:
  contents: read
  actions: read
  issues: write
  pull-requests: read

jobs:
  collect-metrics:
    name: Collect Repository Metrics
    runs-on: ubuntu-latest
    outputs:
      metrics: ${{ steps.metrics.outputs.metrics }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Collect repository metrics
        id: metrics
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // Get current date for reporting period
            const now = new Date();
            const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

            // Repository basic info
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            // Get recent commits
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: thirtyDaysAgo.toISOString(),
              per_page: 100
            });

            // Get recent PRs
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });

            // Get recent issues
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });

            // Filter recent items
            const recentCommits = commits.filter(c => new Date(c.commit.author.date) > sevenDaysAgo);
            const recentPRs = prs.filter(pr => new Date(pr.updated_at) > sevenDaysAgo);
            const recentIssues = issues.filter(issue =>
              !issue.pull_request && new Date(issue.updated_at) > sevenDaysAgo
            );

            // Calculate code metrics
            let codeStats = {};
            try {
              const output = execSync('find githound -name "*.py" -exec wc -l {} + | tail -1', { encoding: 'utf8' });
              const totalLines = parseInt(output.trim().split(' ')[0]);
              codeStats.totalLines = totalLines;

              const fileCount = execSync('find githound -name "*.py" | wc -l', { encoding: 'utf8' });
              codeStats.pythonFiles = parseInt(fileCount.trim());
            } catch (error) {
              codeStats = { totalLines: 0, pythonFiles: 0 };
            }

            const metrics = {
              timestamp: now.toISOString(),
              repository: {
                name: repo.full_name,
                stars: repo.stargazers_count,
                forks: repo.forks_count,
                watchers: repo.watchers_count,
                openIssues: repo.open_issues_count,
                size: repo.size,
                language: repo.language,
                lastUpdated: repo.updated_at
              },
              activity: {
                last7Days: {
                  commits: recentCommits.length,
                  prs: recentPRs.length,
                  issues: recentIssues.length
                },
                last30Days: {
                  commits: commits.length,
                  prs: prs.filter(pr => new Date(pr.updated_at) > thirtyDaysAgo).length,
                  issues: issues.filter(issue =>
                    !issue.pull_request && new Date(issue.updated_at) > thirtyDaysAgo
                  ).length
                }
              },
              code: codeStats,
              contributors: [...new Set(commits.map(c => c.author?.login).filter(Boolean))].length
            };

            // Save metrics to file
            fs.writeFileSync('metrics.json', JSON.stringify(metrics, null, 2));

            return metrics;

      - name: Upload metrics artifact
        uses: actions/upload-artifact@v4
        with:
          name: repository-metrics
          path: metrics.json
          retention-days: 90

  workflow-metrics:
    name: Collect Workflow Metrics
    runs-on: ubuntu-latest
    outputs:
      workflow_metrics: ${{ steps.workflow-metrics.outputs.metrics }}
    steps:
      - name: Collect workflow metrics
        id: workflow-metrics
        uses: actions/github-script@v8
        with:
          script: |
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

            // Get workflow runs
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const workflowMetrics = {};

            for (const workflow of workflows.workflows) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflow.id,
                per_page: 100,
                created: `>=${thirtyDaysAgo.toISOString()}`
              });

              const successfulRuns = runs.workflow_runs.filter(run => run.conclusion === 'success');
              const failedRuns = runs.workflow_runs.filter(run => run.conclusion === 'failure');
              const totalRuns = runs.workflow_runs.length;

              // Calculate average duration for successful runs
              const avgDuration = successfulRuns.length > 0
                ? successfulRuns.reduce((sum, run) => {
                    const duration = new Date(run.updated_at) - new Date(run.created_at);
                    return sum + duration;
                  }, 0) / successfulRuns.length / 1000 / 60 // Convert to minutes
                : 0;

              workflowMetrics[workflow.name] = {
                id: workflow.id,
                totalRuns: totalRuns,
                successfulRuns: successfulRuns.length,
                failedRuns: failedRuns.length,
                successRate: totalRuns > 0 ? (successfulRuns.length / totalRuns * 100).toFixed(2) : 0,
                avgDurationMinutes: avgDuration.toFixed(2),
                lastRun: runs.workflow_runs[0]?.created_at || null
              };
            }

            return workflowMetrics;

  generate-report:
    name: Generate Metrics Report
    runs-on: ubuntu-latest
    needs: [collect-metrics, workflow-metrics]
    steps:
      - name: Generate report
        uses: actions/github-script@v8
        with:
          script: |
            const metrics = ${{ needs.collect-metrics.outputs.metrics }};
            const workflowMetrics = ${{ needs.workflow-metrics.outputs.workflow_metrics }};

            const reportType = '${{ github.event.inputs.report_type }}' || 'daily';
            const date = new Date().toISOString().split('T')[0];

            // Generate markdown report
            const report = `# GitHound Metrics Report - ${date}

            ## 📊 Repository Overview

            - **Stars:** ${metrics.repository.stars} ⭐
            - **Forks:** ${metrics.repository.forks} 🍴
            - **Watchers:** ${metrics.repository.watchers} 👀
            - **Open Issues:** ${metrics.repository.openIssues} 🐛
            - **Repository Size:** ${(metrics.repository.size / 1024).toFixed(2)} MB

            ## 📈 Activity Metrics

            ### Last 7 Days
            - **Commits:** ${metrics.activity.last7Days.commits}
            - **Pull Requests:** ${metrics.activity.last7Days.prs}
            - **Issues:** ${metrics.activity.last7Days.issues}

            ### Last 30 Days
            - **Commits:** ${metrics.activity.last30Days.commits}
            - **Pull Requests:** ${metrics.activity.last30Days.prs}
            - **Issues:** ${metrics.activity.last30Days.issues}
            - **Active Contributors:** ${metrics.contributors}

            ## 💻 Code Metrics

            - **Python Files:** ${metrics.code.pythonFiles}
            - **Total Lines of Code:** ${metrics.code.totalLines.toLocaleString()}

            ## 🔄 Workflow Performance

            | Workflow | Runs | Success Rate | Avg Duration | Status |
            |----------|------|--------------|--------------|--------|`;

            for (const [name, data] of Object.entries(workflowMetrics)) {
              const status = data.successRate >= 90 ? '✅' : data.successRate >= 70 ? '⚠️' : '❌';
              report += `\n| ${name} | ${data.totalRuns} | ${data.successRate}% | ${data.avgDurationMinutes}m | ${status} |`;
            }

            report += `\n\n## 🎯 Key Insights

            - **Most Active Workflow:** ${Object.entries(workflowMetrics).sort((a, b) => b[1].totalRuns - a[1].totalRuns)[0]?.[0] || 'N/A'}
            - **Best Performing Workflow:** ${Object.entries(workflowMetrics).sort((a, b) => b[1].successRate - a[1].successRate)[0]?.[0] || 'N/A'}
            - **Development Velocity:** ${(metrics.activity.last7Days.commits / 7).toFixed(1)} commits/day

            ## 📋 Recommendations

            ${workflowMetrics['CI/CD']?.successRate < 90 ? '- ⚠️ CI/CD success rate is below 90%. Consider investigating recent failures.' : '- ✅ CI/CD pipeline is performing well.'}
            ${metrics.activity.last7Days.commits === 0 ? '- 📉 No commits in the last 7 days. Consider checking development activity.' : '- ✅ Active development detected.'}
            ${metrics.repository.openIssues > 20 ? '- 📝 High number of open issues. Consider triaging and prioritizing.' : '- ✅ Issue count is manageable.'}

            ---
            *Report generated on ${new Date().toISOString()}*
            `;

            // Create or update metrics issue
            const title = `📊 ${reportType.charAt(0).toUpperCase() + reportType.slice(1)} Metrics Report - ${date}`;

            // Check for existing metrics issue
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'metrics,automated',
              state: 'open'
            });

            const existingIssue = existingIssues.find(issue =>
              issue.title.includes('Metrics Report') &&
              issue.title.includes(date)
            );

            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: report
              });
            } else {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: report,
                labels: ['metrics', 'automated', 'documentation']
              });
            }

            console.log('Metrics report generated successfully!');

  health-check:
    name: Repository Health Check
    runs-on: ubuntu-latest
    needs: [collect-metrics, workflow-metrics]
    steps:
      - name: Perform health check
        uses: actions/github-script@v8
        with:
          script: |
            const metrics = ${{ needs.collect-metrics.outputs.metrics }};
            const workflowMetrics = ${{ needs.workflow-metrics.outputs.workflow_metrics }};

            const issues = [];

            // Check workflow health
            for (const [name, data] of Object.entries(workflowMetrics)) {
              if (data.successRate < 70) {
                issues.push(`🔴 Workflow "${name}" has low success rate: ${data.successRate}%`);
              } else if (data.successRate < 90) {
                issues.push(`🟡 Workflow "${name}" success rate could be improved: ${data.successRate}%`);
              }
            }

            // Check activity levels
            if (metrics.activity.last7Days.commits === 0) {
              issues.push('🟡 No commits in the last 7 days');
            }

            // Check issue count
            if (metrics.repository.openIssues > 50) {
              issues.push(`🟡 High number of open issues: ${metrics.repository.openIssues}`);
            }

            if (issues.length > 0) {
              const alertBody = `# 🚨 Repository Health Alert

              The following issues were detected in the repository health check:

              ${issues.map(issue => `- ${issue}`).join('\n')}

              Please review and address these issues to maintain repository health.

              ---
              *Automated health check performed on ${new Date().toISOString()}*`;

              // Create health alert issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `🚨 Repository Health Alert - ${new Date().toISOString().split('T')[0]}`,
                body: alertBody,
                labels: ['health-check', 'priority-medium', 'automated']
              });
            } else {
              console.log('✅ Repository health check passed - no issues detected');
            }
